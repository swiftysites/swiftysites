import Foundation

/// A template for site content.
public struct Template<C: Content>: Sendable {
    
    /// By default the template matches all content of one specific type.
    public static var defaultMatch: Regex<Substring> {
        #/^.*$/#
    }
    
    /// By default the template produces a file named `index` with the corresponding extension.
    public static var defaultIndex: String {
        "index"
    }
    
    /// By default the template produces a file with the `html` extension.
    public static var defaultSuffix: String {
        "html"
    }
    
    /// Defines a template for the first content type.
    ///
    /// - Parameters:
    ///   - match: A regular expresion to indicate which content paths it will apply to –  e.g. a value of `/posts/\w*` will result in the template being applied to all paths that begin with `/posts`.
    ///   - exclude: A regular expresion used to exclude paths from this template – e.g. a value of `/posts|/tags|/` will prevent applying the template to the paths `/`, `/posts` and `/tags` specifically.
    ///   - index: The name of the file being generated at the content's path by this template. If `.none` is specified, the content's path will render as a file instead of directory.
    ///   - suffix: The extension to be appended to the files generated by this template – e.g. `"html` (default), `xml`.
    ///   - apply: The function producing the output's content from a ``Site`` instance and a content item of the corresponding content type.
    ///
    /// In its most simple form a `Template` can be instantiated with a single apply function.
    ///
    /// ```swift
    /// let pageTemplate = Template { (post: Post) in """
    ///     <h1>\(post.title)</h1>
    ///     <article>
    ///         <main>\(post.content)</main>
    ///     </article>
    /// """ }
    /// ```
    ///
    /// See <doc:Template> for more elaborate examples and explanations.
    ///
    public init(_ match: Regex<Substring> = Template.defaultMatch, exclude: Regex<Substring>? = .none, index: String? = Template.defaultIndex, suffix: String? = Template.defaultSuffix, apply: @Sendable @escaping (C) -> String) {
        self.match = match
        self.exclude = exclude
        self.index = index
        self.suffix = suffix
        self.apply = apply
    }

    nonisolated(unsafe) let match: Regex<Substring>
    nonisolated(unsafe) let exclude: Regex<Substring>?
    let index: String?
    let suffix: String?
    
    // let pattern: any RegexComponent
    let apply: @Sendable (C) -> String

    func apply(_ contentItems: [C], baseURL: URL) -> [URL] {
        contentItems.compactMap { contentItem in
            apply(contentItem, baseURL: baseURL)
        }
    }

    func apply(_ content: C, baseURL: URL) -> URL? {
        if content.path.wholeMatch(of: match) == nil {
            return nil
        }
        if let exclude, content.path.wholeMatch(of: exclude) != nil {
            return nil
        }
        let fileWithoutExt = URL(fileURLWithPath: content.path).deletingPathExtension()
        let fileWithIndex: URL
        if let index = index {
            fileWithIndex = fileWithoutExt.appendingPathComponent(index)
        } else {
            if fileWithoutExt.pathComponents.count > 1 {
                fileWithIndex = fileWithoutExt
            } else {
                fileWithIndex = fileWithoutExt.appendingPathComponent(Template.defaultIndex).appendingPathExtension(Template.defaultSuffix)
            }
        }
        let newFile: URL
        if let suffix = suffix {
            newFile = fileWithIndex.appendingPathExtension(suffix)
        } else {
            newFile = fileWithIndex
        }

        let originalMapFile = baseURL.appendingPathComponent(newFile.path)
        let mapFile: URL
        if originalMapFile.lastPathComponent == "\(Template.defaultIndex).\(Template.defaultSuffix)" {
            // Correct all index.html
            mapFile = originalMapFile.deletingLastPathComponent()
        } else {
            mapFile = originalMapFile
        }

        let output = apply(content)

        writeFile(output, newFile)
        // TODO: check if we are replacing a directory with a file, in which case we need to manually delete beforehand
        
        return mapFile // TODO: Eliminate duplicates
    }
}
